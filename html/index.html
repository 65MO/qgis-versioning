<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Tempus" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

        <title>Versioning</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">

          <h1 id="project_title">Versioning</h1>

          <a href="index.html">About</a> | <a href="authors.html">Authors</a> | <a href="documentation.html">Documentation</a> | <a href="dev.html">Development</a> | <a href="screencast.html">Screencast</a> | <a href="installation.html">Installation</a>

            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">

<h3>About</h3>

<p>
Versioning of posgresql/postGIS data that allows for a classical workflow of revision control: checkout, update, commit. The working copy is a spatilite database.
</p>

<h4>Principe</h4>


<a name="revision_table"></a>
<p>
The database is stored in a postgresql schema, the complete schema is versioned (i.e. not individual tables). Revisions are identified by a revision number. A revision table in the versionned schema, called <strong>revisions</strong>, keeps track of the date, author, commit message and branch of all revisions.
</p>

<p>
Once a table structure is defined, three operations can be performed on rows: INSERT, DELETE and UPDATE. To be able to track history, every row is kept in the tables. Deleted rows are marqued as such and updated rows are a combined insertion-deletion where the deleted and added rows are linked to one another as parent and child.
</p>

<p>
A total of five columns are needed for versionning the first branch:
<p>
<ul>
    <li><strong>hid</strong>: a unique identifier accross the table</li>
    <li><strong>branch_rev_begin</strong>: revision when this record was inserted</li>
    <li><strong>branch_rev_end</strong>: last revision for wich this record exist (i.e. revision when it was deleted minus one)</li>
    <li><strong>branch_parent</strong>: in case the row has been inserted as the result of an update, this fields stores the hid of the row that has been updated</li>
    <li><strong>branch_child</strong>: in case the row has been marked as deleted as the result of an update, this field stores the hid of the row that has been inserted in its place.</li>
</ul>
<p>
For each additionnal branch, four additional columns are needed (the ones with the prefix <strong>branch_</strong>).
</p>

<p>
<strong>Note</strong>: if the branch_rev_begin is null, it means that a row belongs to another branch.
<p>

<p>
SQL views are used to see the database for a given revision number. If we note <em>rev</em> the revision we want to see. For each table, the condition for a row to be present is the view is:
</p>
<code>(branch_rev_end IS NULL OR branch_rev_end &gt;= rev) AND branch_rev_begin &lt;= rev</code>
<a name="head_revision"></a>
<p>In the special case of the current revision, or <strong>head revision</strong>, the condition reads:
</p>
<code>branch_rev_end IS NULL AND branch_rev_begin IS NOT NULL</code>

<p>
<strong>Note</strong>: since elements are not deleted (but merely marked as such) from an historized table, care must be taken with the definition of constrains (in particular, the conceptual unicity of a field values). TODO: give a solution to this problem, probably involves creating a <a href=http://www.postgresql.org/docs/current/interactive/indexes-partial.html#INDEXES-PARTIAL-EX3>partial index</a>. 
</p>

<p>
Withing the prosgres database, the views on revisions must be readonly and historized tables should not be eddited directly. This is a basic priciple for version control: editions must be made to working copies an then commited to the databse. 
</p>

<h4>Working copies (checkout)</h4>

<p>
Working copies are meant to be used offline. Therefore the priviledged format for spatial databases is spatialite. Of course, the mecanisms described hereafter to update the working copy could also be implemented in posgresql/postGIS is need be.
</p>

<p>
A working copy consist of the versionned tables of a given versionned database (i.e. posgresql schema) or any subset. For each table, only the elements that have not been marked as deleted in the head revision need to be prensent. Furthermore only a subset of the elements the user needs to edit can be selected (e.g. a spatial extend).
</p>

<p>
To create a working copy (i.e. to checkout), tables from the versionned schema (or the afformentionned subsets) are converted to a spatialite database. 
</p>

<p>
<strong>Note</strong>: the constrains on the tables could be lost in the postGIS to spatialite conversion. It may be usefull to store spatialite commands to restore those constrains in the postgresql database.
</p>

<p>
For each versionned table in the working copy, we create a view with the <strong>suffix _view</strong> (e.g. mytable_view). Those views typically filters out the historization columns and shows the <a href=#head_revision>head revision</a>. A set of <strong>spatialite triggers</strong> is defined to allow updating on those views.
</p>

<h5>Delete trigger</h5>

<p>
The update trigger simply marks the end revision of a given record.
</p>
<pre>
CREATE TRIGGER delete_mytable INSTEAD OF DELETE ON mytable_view
  BEGIN
    UPDATE mytable SET branch_rev_end = (SELECT rev FROM initial_revision) WHERE OGC_FID = old.OGC_FID;
  END;
</pre>



<h5>Insert trigger</h5>

<p>
The insert trigger create a new record and fills the branch_rev_begin field.
</p>

<pre>
CREATE TRIGGER insert_mytable INSTEAD OF INSERT ON mytable_view
  BEGIN
    INSERT INTO mytable 
      (OGC_FID, column2_in_view, column3_in_view, ..., trunk_rev_begin)
    VALUES
      ((SELECT MAX(ogc_fid) + 1 FROM mytable), new.column2_in_view, new.column3_in_view, ..., (SELECT rev FROM initial_revision) + 1 );
    END;
</pre>

<h5>Update trigger</h5>

<p>
The update trigger create a new record and fills the branch_rev_begin and branch_parent fields. It then marks the parent record as deleted, and fills the branch_rev_end and branch_child fields.</p>

<pre>
CREATE TRIGGER update_mytable INSTEAD OF UPDATE ON mytable_view
  BEGIN
    INSERT INTO mytable
      (OGC_FID, column2_in_view, column3_in_view, ..., trunk_rev_begin, trunk_parent)
    VALUES
      ((SELECT MAX(ogc_fid) + 1 FROM mytable), column2_in_view, column3_in_view, ..., (SELECT rev FROM initial_revision) + 1, old.OGC_FID);
    UPDATE mytable SET trunk_rev_end = (SELECT MAX(ogc_fid) FROM junctions), trunk_child = (SELECT MAX(ogc_fid) FROM mytable) 
    WHERE OGC_FID = old.OGC_FID;
  END;
</pre>

<h4>Updating the working copy (update)</h4>

<p>
Changes can be made to the database while editting the worling copy. In order to reconcile those edition, the user needs to update the working copy. 
</p>

<p>
TODO: fill this section
</p>

<h4>Committing the editions to the versionned database (commit)</h4>

<p>
If a working copy is up to date, the editions can be integrated in the versionned database. This operation consists simply in the insertion of a record in the <a href=#revision_table>revisions table</a>, and, for each versionned table, in updating rows that are different and inserting rows that are not present.
</p>

      </section>
    </div>

  </body>
</html>
